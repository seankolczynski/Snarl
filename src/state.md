We have attached a UML for help with visualization:

To start with the basics, our GameState interface would need to contain some sort of view function, as somehow we must have a visual representation of the game that a human could understand. This view could be ascii to start, but will probably use nicer graphics in the final version, such as Pygame. To draw the game, the GameState needs a List of Levels, which will contain Rooms with a List of List of Tiles, and Hallways which contain a list waypoints. These classes will contain a corresponding tile for each position that could be taken within it, with that tile either being a walkable space or a wall which can hold a character or an item. These classes are important, as all other aspects of the game need to be placed somewhere in a room or hallway. To represent an exit we will consider that an item. 
	To move further into the design, we want to have procedurally generated GameStates. To achieve this, we would probably have a supply of pre-designed Rooms, which are essentially patterns of Tiles that we find to be fit for use in game. The GameState would generate this assortment of rooms. It would then have to connect these rooms with hallways, and maintain that there is no overlap. This generation would be a bit difficult, but could be pretty easy if the given rooms are all similar in size.
	The other important things that the GameState needs to maintain is the location of all Characters and Items in the game. Both would be stored in a list of Characters and Items. At  some point in the game, the Characters and Items will be moving/changing, and thus, the GameState must have a way to move Items and Characters to the board. This would be best done with some move method that takes in a Character and a new Position (which is just an int x and int y tuple). If a Player moves to a Tile with a key it picks it up automatically and clears the tile, adding it to its inventory. If an adversary moves to a tile with a player, that player dies.


